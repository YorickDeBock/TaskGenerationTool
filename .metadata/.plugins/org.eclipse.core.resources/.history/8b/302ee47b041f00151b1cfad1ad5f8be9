package be.uantwerpen.tacle.tasksetgenerator;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.Writer;
import java.io.ObjectInputStream.GetField;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.Vector;



public class Test {
	
	private double Pi; 		// period
	private double Theta;	// execution time
	private int m_prime;	// number of VCPU
	private Vector<Task> taskset;
	public double Dk;

	public static void main(String[] args) {
		Test test;
		double maxAk;
		double demand=0;
		double supply=0;
		int nonFAk=0;
		boolean feasible = false;
		try {
			PrintWriter writer1 = new PrintWriter("theorie.txt", "UTF-8");
		 
		for(int m=2;m<4;m++)
		{
			writer1.println("VCPUs: "+m);
			for(int t=(m-1)*20+1;t<=m*20;t++)
			{
				writer1.println("Theta: "+t);
				test = new Test(20,t,m);
				for(int k=0;k<test.sizeTaskset();k++)
				{
					writer1.println("Task index: "+k);
					maxAk = test.getMaxAk(k, 1);
					writer1.println("Max Ak: "+maxAk);
					feasible = false;
					nonFAk = -1;
					for(int a=0;a<=Math.ceil(maxAk);a++)
					{
						demand = test.getDBF(a, m,k);
						supply = test.getsbf(a+test.Dk);
						if(demand>supply)
						{
							nonFAk=a;
							feasible = false;
							break;
						}
						feasible =true;
					}
					
					writer1.println("Task feasible ("+nonFAk+"): "+feasible);
					writer1.println("Demand: "+demand+" , supply: "+supply);
					writer1.println();
				}
				writer1.println();
			}
			writer1.println();
		}
		writer1.close();
		}
		catch (FileNotFoundException | UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	public Test(double pi,double theta,int cpus)
	{
		this.Pi = pi;
		this.Theta = theta;
		this.m_prime = cpus;
		this.taskset = new Vector<Task>();
		taskset.add(new Task("T1","580","380","115"));
		taskset.add(new Task("T2","425","660","25"));
		taskset.add(new Task("T3","670","590","180"));
		taskset.add(new Task("T4","470","690","491"));
		//taskset.add(new Task("T4","355","355","7"));
		//taskset.add(new Task("T4","715","715","215"));
		//taskset.add(new Task("T4","500","500","49"));
		//taskset.add(new Task("T4","665","665","127"));
		//taskset.add(new Task("T4","400","400","37"));
		//taskset.add(new Task("T4","400","400","37"));
	}
	public int sizeTaskset()
	{
		return this.taskset.size();
	}
	public double getsbf(double t)
	{
		double Theta_part = this.Theta - (this.m_prime - 1)*Pi;
		double y = Math.floor( (t - (this.Pi - Theta_part)) / this.Pi);
		double result = y * Theta_part + Math.max(0, t - 2*(this.Pi-Theta_part)-y*this.Pi) + (this.m_prime-1)*t;
		return result;//
	}
	public double getMaxAk(int k,int whichSchedTest){
		
		final Vector<Task> workload;
		workload = this.taskset;
		Task task_k = this.taskset.get(k);
		
		double AkMax = 0;	
		double[] workload_exes = new double[workload.size()]; //ATT:must after workload initilization
		double C_sum = 0;
		double U_tau = 0;
		double U = 0;
		double B = 0;		

		//initialize the intermediate variable
		for(int i=0; i<workload.size();i++){
			workload_exes[i] = workload.get(i).getExe();
		}
		Arrays.sort(workload_exes); 	//in ascending order
		for(int i=1; i<=m_prime-1;i++){
			if(workload.size()-i < 0) break;
			C_sum = C_sum + workload_exes[workload.size()-i];
		}
		for(int i=0; i<workload.size();i++){
			U_tau = U_tau + workload.get(i).getExe()/workload.get(i).getPeriod(); 
			U = U + (workload.get(i).getPeriod() - workload.get(i).getDeadline()) * (workload.get(i).getExe() / workload.get(i).getPeriod());
		}
		B = B + (Theta / Pi) * (2 + 2*(Pi - Theta/m_prime));
		//B = B + (Theta / Pi) * (2+2*(Pi - (Theta- (m_prime-1)*Pi)));
		if(whichSchedTest == 1){
			AkMax = (C_sum + m_prime*task_k.getExe() - task_k.getDeadline()*(Theta/Pi - U_tau) + U + B) / (Theta/Pi - U_tau);
		}else if(whichSchedTest == 2){
			double B_meng = m_prime * (2 + 2*(Pi - (m_prime -1)));
			AkMax = (C_sum + m_prime*task_k.getExe() - task_k.getDeadline()*(m_prime -1 - U_tau) + U + B_meng) / (m_prime -1 - U_tau);
		}
		return Math.max(0, AkMax);
	}
	
	public double getDBF(double Ak, int m_prime, int k){ // t_Ak_Dk is A_k+D_k, k is the index of task k.
		Vector<Task> workload = this.taskset; //The non-leaf component has no taskset; It only has interface tasks;
		double[] I2_bars = new double[workload.size()];
		double[] I2_hats = new double[workload.size()];
		double[] diff_I2bars_I2hats = new double[workload.size()];
		Task task_k = workload.get(k);
		this.Dk = task_k.getDeadline();
		double t_Ak_Dk = Ak + this.Dk;
		
		//Calculate the Ibar_{i,2} for all i
		for(int i=0; i<workload.size(); i++){
			Task currentTask = workload.get(i);
			if(i == k){
				I2_bars[i] = Math.min(task_k.getWorkload(t_Ak_Dk)-task_k.getExe(), Ak);
			
			}else{
				I2_bars[i] = Math.min(currentTask.getWorkload(t_Ak_Dk), t_Ak_Dk - task_k.getExe());
			}
			
		}
		//Calculate the Ihat_{i,2} for all i
		for(int i=0; i<workload.size(); i++){
			Task currentTask = workload.get(i);
			if(i == k){
				I2_hats[i] = Math.min(task_k.getWorkload(t_Ak_Dk) - task_k.getExe() - task_k.getCI(t_Ak_Dk), Ak);
			}else{
				I2_hats[i] = Math.min(currentTask.getWorkload(t_Ak_Dk) - currentTask.getCI(t_Ak_Dk), t_Ak_Dk - task_k.getExe());
			}
		}
		//Calculate L_{m'-1}, the max (m'-1) (Ibar_2 - Ihat_2)
		for(int i=0; i<workload.size(); i++){
			diff_I2bars_I2hats[i] = Math.max(0, I2_bars[i] - I2_hats[i]); //The m'-1 carry tasks' workload, which cannot be negative
		}
		Arrays.sort(diff_I2bars_I2hats); //sort in ascending order
		//Debug the sort result
		//System.out.println("Sorted array in ascending order.");
		//for(int i=0; i<workload.size(); i++){
		//	System.out.print("" + diff_I2bars_I2hats[i] + ",");
		//}
		//System.out.flush();
		//System.out.println("\n");
		
		//DEM(A_k+D_k,m') equation
		double result = 0;
		result = m_prime*task_k.getExe();
		for(int i=0; i<workload.size(); i++){
			result = result + I2_hats[i];
		}
		for(int i=1; i <= Math.min(m_prime-1, workload.size()); i++){
			result = result + diff_I2bars_I2hats[workload.size()-i];
		}
		
		return result;	
		
	}
	
}

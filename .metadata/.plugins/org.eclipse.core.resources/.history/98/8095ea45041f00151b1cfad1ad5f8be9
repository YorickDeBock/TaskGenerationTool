package be.uantwerpen.tacle.tasksetgenerator;

import java.io.*;
import java.text.DecimalFormat;
import java.util.*;
import java.util.Map.*;


public class CollectTaskInformation {
	
	private Map<String,File[]> map = null;
	private Map<String,File> mapT = null;
	private Map<String,ArrayList<Double>> mapInput = null;
	private String scheduler;
	private String directory;
	private String extra;

	public CollectTaskInformation(String dir, String sched, String extra){
		this.directory=dir;
		this.scheduler = sched;
		this.extra = extra;
		map = new TreeMap<String,File[]>();
		mapT = new TreeMap<String,File>();
		mapInput = new TreeMap<String,ArrayList<Double>>();
	}
	public void checkCorrectTaskset()
	{
		XMLInterpreter input;
		ArrayList<Double> periodList;
		ArrayList<String> bucht = new ArrayList<String>();
		for(Entry<String, ArrayList<Double>> en:mapInput.entrySet())
		{
			periodList=en.getValue();
			input = new XMLInterpreter(directory+"\\"+en.getKey()+"\\"+en.getKey()+".xml");
			input.parseFile();
			for(Component VM:input.getRootComponent().getChildComponents()){
				for(Task t:VM.getTaskset())
					if(periodList.contains(t.getPeriod()))
						periodList.remove(t.getPeriod());
					else
					{
						if(!bucht.contains(en.getKey()))
							bucht.add(en.getKey());
					}
			}
		}
		System.out.println(bucht.size());
		for(String s:bucht)
		{
			System.out.println("rm -R "+s);
		}
	}
	public void ScanDirs()
	{
		File dir = new File(directory+"/.");
		File[] directories = dir.listFiles(File::isDirectory);
		File[] fs; 		
		
		FilenameFilter filter = new FilenameFilter() {
	        public boolean accept(File directory, String fileName) {
	            return fileName.contains("results");}
			};
		FilenameFilter filter2 = new FilenameFilter() {
	        public boolean accept(File directory, String fileName) {
	            return fileName.contains("interface");}
			};
		for(File f:directories)
		{
			if(f.getName().contains(scheduler)&&f.getName().contains(extra))
			{
				//System.out.println("\n"+f.getName());
				fs = new File[f.list(filter).length];
				fs = f.listFiles(filter);
				map.put(f.getName(), fs);
				fs = new File[f.list(filter2).length];
				fs = f.listFiles(filter2);
				mapT.put(f.getName(),fs[0]);	
				
			}
		}
	}
	public void calcDeadlinesMisses(int minLoad,int maxLoad, int step)
	{
		FileInputStream in;
		BufferedReader br;
		String tmp ;
        double totaljobs,totalDeadlineMisses,period;
        String[] parts;
		double load;
			
		TreeMap<Double,LoadInfo> deadlineMisses = new TreeMap<Double,LoadInfo>();
		TreeMap<Double,Integer> schedulableTaskSets = new TreeMap<Double,Integer>();
		ArrayList<Double> periods;
		
		for(double i=minLoad;i<=maxLoad;i+=step)
		{
			schedulableTaskSets.put(i,0);
		}
			
		for(Entry<String,File[]>en:map.entrySet())
		{
			parts = en.getKey().split("_");
			load = Double.parseDouble(parts[1]);
			totaljobs = 0;
			totalDeadlineMisses = 0;
			periods = new ArrayList<Double>();
			for(File f:en.getValue())
			{
				
				try {
		        	/*if(f.length()==0)
		        			System.out.println(en.getKey()+" "+f.getName()+" is emty!");*/
		        	in = new FileInputStream(f);
			        br = new BufferedReader(new InputStreamReader(in));
					while ((tmp = br.readLine()) != null) {
						if(tmp.contains("Jobs"))
						{
							parts=tmp.split(": ");
							totaljobs+=Integer.parseInt(parts[1]);
						}
						if(tmp.contains("Missed Deadlines"))
						{
							parts=tmp.split(": ");
							
							if(Integer.parseInt(parts[1])>1)
							{
								totalDeadlineMisses+=Integer.parseInt(parts[1]);
								System.out.println(en.getKey()+" "+f.getName()+" "+Integer.parseInt(parts[1]));
							}
						}
						if(tmp.contains("Period"))
						{
							parts=tmp.split(": ");
							period=Double.parseDouble(parts[1]);
							periods.add((double) Math.round(period*1000));
						}
					}
					
		        } catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			if(totalDeadlineMisses==0)
			{
				schedulableTaskSets.put(load,(schedulableTaskSets.get(load))+1);
			}
			if(totaljobs!=0)
			{
				if(deadlineMisses.containsKey(load))
				{
					deadlineMisses.get(load).addTasksDeadlineInfo(totalDeadlineMisses, totaljobs);
				}
				else
				{
					deadlineMisses.put(load, new LoadInfo(totalDeadlineMisses,totaljobs));
				}	
			}
			mapInput.put(en.getKey(), periods);
		}
	
		for(Entry<Double, Integer> en:schedulableTaskSets.entrySet()){
			System.out.println("Load: "+en.getKey()+" schedulable task sets: "+en.getValue());
		}
		DecimalFormat df = new DecimalFormat("####0.0000");
		String output = "";
		PrintWriter toCSV = null;
		try {
			toCSV = new PrintWriter("Output.csv");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		toCSV.println("load;deadlineMissRatio");
		for(Entry<Double, LoadInfo> en : deadlineMisses.entrySet()){
			output = "Load: "+en.getKey()+" DeadlineMissRation: "+df.format(en.getValue().getRatio())+" TotalJobs: "+
					en.getValue().getTotalAmountofTasks() + " TotalDeadlineMisses: "+en.getValue().getDeadlineMisses();
			//System.out.println(output);
			toCSV.println(String.valueOf(en.getKey())+";"+String.valueOf(df.format(1-en.getValue().getRatio())));
		}
		toCSV.close();		
	}
	public void calcTheoryLoad()
	{
		List<Interface> interfaces;
		double period=0,exec=0,load=0;
		File f;
		String[] parts;
		int i=0;
		DecimalFormat df = new DecimalFormat("####0.0000");
		TreeMap<Double,InterfaceLoad> theoriticalLoad = new TreeMap<Double,InterfaceLoad>();
		for(Entry<String,File>en:mapT.entrySet())	
		{
			period=20;exec=0;load=0;
			f = en.getValue();
			XMLInterpreter output = new XMLInterpreter(f);
			output.parseFile();
			Interface interfaceRoot = output.getRootInterface();
			interfaces = interfaceRoot.getChildComponents();
			for(Interface inter:interfaces){
				for(Task task:inter.getTaskset()){
					exec+=task.getExe();
				}
			}
			parts = en.getKey().split("_");
			load = Double.parseDouble(parts[1]);
			if(theoriticalLoad.containsKey(load))
			{
				theoriticalLoad.get(load).addInterfaceInfo(exec);
			}
			else
			{
				theoriticalLoad.put(load, new InterfaceLoad(exec,period));
			}
		}
		for(Entry<Double,InterfaceLoad> en:theoriticalLoad.entrySet())
		{
			System.out.println("Load: "+en.getKey()+" mean load of interfaces: "+df.format(en.getValue().getRatio())+" schedulable Task sets: "+en.getValue().getSchedudableTasksset());
		}
			
	}
	public int sbfBock(int t,double theta, double pi, int m)
	{
		double thetaP = theta - (m-1)*pi;
		
		int sbf = (m-1)*t;
		
		sbf += Math.floor((t-(pi-thetaP))/pi)*thetaP;
		sbf += Math.max(t-2*(pi-thetaP) - pi*Math.floor((t-(pi-thetaP))/pi)*pi,0);
		
		return sbf;
	}
	public static void main(String[] args) {

			CollectTaskInformation taskInfo = new CollectTaskInformation("C://Users//Onderzoeker//Desktop//RT-Xen_Results//Taskset-rt//output","gEDF","");
			taskInfo.ScanDirs();
			taskInfo.calcTheoryLoad();
			taskInfo.calcDeadlinesMisses(110, 990, 20);
			taskInfo.checkCorrectTaskset();
			//System.out.println(taskInfo.sbfBock(475, 9, 20, 1));
			
	}

}

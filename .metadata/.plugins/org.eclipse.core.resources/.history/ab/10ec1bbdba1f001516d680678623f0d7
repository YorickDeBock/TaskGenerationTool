package be.uantwerpen.tacle.tasksetgenerator;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.*;

public class SetsGenerator {

	/*
	 * @param: osScheduler: de scheduler of the hypervisor
	 * @Param: periodmin,periodmax,periodStep: the uniform distribution of taks period between [periodmax,periodmin] with a step x ms
	 * @Param:setsPerLoad: per load and binomal distribution to generated sets must be generated (min is 1)
	 */
	
	static final String NAME 			= "name";
	static final String LOCATION 		= "tasksetlocation";
	static final String UTIL_MIM 		= "globalUtilizationMin";
	static final String UTIL_MAX 		= "globalUtilizationMax";
	static final String UTIL_STEP 		= "utilizationStep";
	static final String NUM_TASKS 		= "numberOfTasks";
	static final String NUM_TASKSETS 	= "numberOfTaskSets";
	static final String PERIOD_MIN 		= "periodMin";
	static final String PERIOD_MAX 		= "periodMax";
	static final String PERIOD_STEP 	= "periodStep";
	static final String SEED 			= "seed";

	
	private List<Task> taskset;
	private Map<String, List<String>> params;
	
	public SetsGenerator (){
		
	}
	
	public void generateTaskset()
	{
		int setsperload = Integer.parseInt(params.get(NUM_TASKSETS).get(0));
		String name = params.get(NAME).get(0);
		String taskSetName = null;
		double minLoad =  Double.parseDouble(params.get(UTIL_MIM).get(0));
		double maxLoad = Double.parseDouble(params.get(UTIL_MAX).get(0));
		double stepLoad = Double.parseDouble(params.get(UTIL_STEP).get(0));
		int minPeriod = Integer.parseInt(params.get(PERIOD_MIN).get(0));
		int maxPeriod = Integer.parseInt(params.get(PERIOD_MAX).get(0));
		int stepPeriod = Integer.parseInt(params.get(PERIOD_STEP).get(0));
		int numberTasks = Integer.parseInt(params.get(NUM_TASKS).get(0));
		
		PrintWriter writer = null;
		
		try {
			writer = new PrintWriter(name+".xml");
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
		for(double load=minLoad;load<=maxLoad;load+=stepLoad)
		{
			for(int i=1;i<2;i++)
			{

				for(int j=0;j<setsperload;j++)
				{
					taskSetName = new Double(Math.round(100*load)).toString()+"_"+j;
					createTasks(minPeriod,maxPeriod, stepPeriod ,load,numberTasks);
					writer.print(XMLgenerator(taskSetName,"test",i));
				}
			}
		}
		writer.close();
	}
	
	private List<Double> genTaskUtils(int numTask, double utilization)
	{
		boolean discard;
		List<Double> taskUtils = new ArrayList<Double>;
		do {
			double sumU = utilization;
			discard = false;
			for (int i = 0; i < numTask - 1; i++) {
				nextSumU = sumU * Math.pow(random.nextDouble(), (double) 1 / (nbTask - (i + 1)));
				util[i] = sumU - nextSumU;
				sumU = nextSumU;
				if (util[i] > 1) {
					discard = true;
				}
			}
			util[numTask - 1] = sumU;
			if (util[nbTask - 1] > 1) {
				discard = true;
			}
		} while (discard || !utilizationIsValid(util));
		return util;
	}
	
	public void createTasks(double periodmin, double periodmax, double periodStep, double tasksetUtil, int numberTasks)
	{
		Random random = new Random(Integer.parseInt(params.get(SEED).get(0)));
		Random random1 = new Random(Integer.parseInt(params.get(SEED).get(0)));
		double period=0,exec;
		double taskUtil=0;
		double tempUtil;
		double chooser;
		//int j=0;
		Task task = null;
		taskset = new ArrayList<Task>();
		
		double sumU = tasksetUtil;
		double nextSumU;
		for(int i=1;i<=(numberTasks-1);i++)
		{
			
			nextSumU = sumU*Math.pow(random1.nextDouble(),(1/(numberTasks-i)));
			taskUtil = sumU-nextSumU;
			sumU = nextSumU;
			
			
					
			period = (int)(Math.round((random.nextDouble()*(periodmax/periodStep-periodmin/periodStep)+periodmin/periodStep))*periodStep);
			exec = (int)Math.round(taskUtil*period);
			tempUtil = exec/period;
			
			if(tempUtil<0.001||tempUtil>0.9)
			{
				i--;
				System.out.println("test");
				continue;
			}
			//j++;
			task = new Task();
			task.setExe(exec);
			task.setPeriod(period);
			task.setDeadline(period);
			task.setName("Task "+(taskset.size()+1));
			if(this.getTasksetUtil()+tempUtil>tasksetUtil)
				break;
			taskset.add(task);
		}
		period = (int)(Math.round((random.nextDouble()*(periodmax/periodStep-periodmin/periodStep)+periodmin/periodStep))*periodStep);
		exec = (int)Math.round(taskUtil*period);
		tempUtil = exec/period;
		task.setExe((int)Math.round(sumU*period));
		task = new Task();
		task.setExe(exec);
		task.setPeriod(period);
		task.setDeadline(period);
		task.setName("Task "+(taskset.size()+1));
		taskset.add(task); 
		
		Collections.sort(taskset);
	}
	private double getTasksetUtil()
	{
		if(taskset.isEmpty())
			return 0;
		double util=0;
		for(Task t:taskset)
			util+=t.getExe()/t.getPeriod();
		return util;
	}
	public String XMLgenerator(String taskSetName,String osScheduler,int binomal)
	{
		String resultString = "<taskSet name=\""+taskSetName+"\" period=\"10.0\">\n";
		
		for(Task t: taskset)
		{
			resultString = resultString+"<task name=\""+t.getName()+"\" p=\""+t.getPeriod()+"\" d=\""+t.getDeadline()+"\" e=\""+t.getExe()+"\" />\n";
		}
		resultString +=  "</taskSet>\n";
		return resultString;
	}
	
	private void checkInput(String fileName)
	{
		XMLParser parser = new XMLParser(fileName);
		boolean check=true;
		parser.parseFile();
		params = parser.getParameters("TaskSet");
		//check if all parameters are included
		if(!params.containsKey(LOCATION))
			check = false;
		if(!params.containsKey(UTIL_MIM))
			check = false;
		if(!params.containsKey(UTIL_MAX))
			check = false;
		if(!params.containsKey(UTIL_STEP))
			check = false;
		if(!params.containsKey(NUM_TASKS))
			check = false;
		if(!params.containsKey(NUM_TASKSETS))
			check = false;
		if(!params.containsKey(PERIOD_MIN))
			check = false;
		if(!params.containsKey(PERIOD_MAX))
			check = false;
		if(!params.containsKey(PERIOD_STEP))
			check = false;
		if(!params.containsKey(SEED))
			check = false;
		if(!check)
		{
			System.err.println("Some parameters are missing");
		}
	}
	
	public static void main(String[] args) {
			
		SetsGenerator gen = new SetsGenerator();
		gen.checkInput("user.xml");
		gen.generateTaskset();
	}
}
